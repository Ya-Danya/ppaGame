# PROTOCOL — PaperFX (TCP, JSON Lines)

## 0. Общая идея

Игра работает по клиент‑серверной модели, **сервер авторитетный**:

- **Клиент** отправляет только ввод (направление движения), команды комнат/чата/профиля и запросы авторизации.
- **Сервер** рассчитывает игровую физику, захват территории, убийства, начисление очков и **рассылает** состояние всем участникам комнаты.

---

## 1. Транспорт и формат сообщений

**Транспорт:** TCP.

- Java: `ServerSocket` (сервер) + `Socket` (клиент и серверная сторона соединения).
- Кодировка: UTF‑8.
- Формат обмена: **JSON Lines (JSONL)** — *каждое сообщение это ровно 1 строка JSON*.
- Разделитель сообщений: `\n`.

Ограничения:
- Сообщения не должны содержать перевод строки внутри JSON.
- Сервер читает входящие сообщения построчно (`BufferedReader.readLine()`), клиент пишет построчно (`PrintWriter.println()`).

---

## 2. Общий конверт

Каждое сообщение содержит поле:

- `type: string` — тип сообщения.

Поля зависят от `type`.

---

## 3. Авторизация

До авторизации сервер **не принимает** игровые команды (`input`, `chat_send`, `join_room`, ...).

### 3.1 register (клиент → сервер)

```json
{"type":"register","username":"jez","password":"secret"}
```

Ответ:
- либо `auth_ok` (см. ниже),
- либо `error`.

### 3.2 login (клиент → сервер)

```json
{"type":"login","username":"jez","password":"secret"}
```

Ответ:
- либо `auth_ok`,
- либо `error`.

### 3.3 auth_ok (сервер → клиент)

```json
{
  "type":"auth_ok",
  "userId":"<uuid-or-id>",
  "username":"jez",
  "roomId":"MAIN",
  "spectator":false,
  "color":"#4CC9F0",
  "bestScore":123
}
```

Пояснения:
- `roomId`/`spectator` — текущий режим после автоприсоединения.
- `color` — цвет игрока в комнате (для отрисовки территории/следа).
- `bestScore` — лучший счёт игрока за всё время (top-score).

> После `auth_ok` сервер автоматически пытается присоединить игрока к **главной комнате**.

---

## 4. Комнаты и режим наблюдателя

Комната — независимая игра. Сервер поддерживает несколько комнат одновременно.

### 4.1 create_room (клиент → сервер)

Создать комнату с указанным идентификатором.

```json
{"type":"create_room","roomId":"ROOM-123"}
```

Ответы:
- `room_joined` (если создание/вход успешны)
- `error` (например, неверный id)

### 4.2 join_room (клиент → сервер)

Войти в комнату игроком или наблюдателем.

```json
{"type":"join_room","roomId":"MAIN","spectator":false}
```

Наблюдатель:

```json
{"type":"join_room","roomId":"MAIN","spectator":true}
```

Сервер обязан соблюдать вместимость комнаты:
- максимум **4 игрока** одновременно в комнате,
- наблюдатели не занимают слот игрока.

### 4.3 room_joined (сервер → клиент)

```json
{
  "type":"room_joined",
  "roomId":"MAIN",
  "capacity":4,
  "spectator":false,
  "playerId":"<player-entity-id>",
  "players":3
}
```

Если клиент вошёл как наблюдатель, `playerId` может отсутствовать.

---

## 5. Игровой ввод

### input (клиент → сервер)

Клиент отправляет направление движения:

```json
{"type":"input","dx":1,"dy":0}
```

Где:
- `dx ∈ {-1,0,1}`
- `dy ∈ {-1,0,1}`
- Диагональ запрещена (клиент нормализует, сервер тоже должен быть устойчив к некорректным значениям).

---

## 6. Чат (привязан к комнате)

### 6.1 chat_send (клиент → сервер)

```json
{"type":"chat_send","text":"Привет!"}
```

### 6.2 chat_msg (сервер → клиент, broadcast по комнате)

```json
{"type":"chat_msg","roomId":"MAIN","from":"jez","text":"Привет!","ts":1730000000000}
```

`from` может быть `"SYSTEM"` для системных уведомлений (в т.ч. достижения).

---

## 7. Состояние игры

### state (сервер → клиент, broadcast по комнате)

Сервер периодически (тик) отправляет снапшот:

```json
{
  "type":"state",
  "tick":12345,
  "roomId":"MAIN",
  "cell":10,
  "w":80,
  "h":60,
  "owners":[0,0,1,1,...],
  "players":[
    {
      "id":"<playerId>",
      "idx":1,
      "username":"jez",
      "x":120.5,
      "y":80.0,
      "score":42,
      "color":"#4CC9F0",
      "trail":[{"x":10,"y":5},{"x":11,"y":5}]
    }
  ],
  "leaderboard":[{"username":"jez","bestScore":42}]
}
```

Пояснения:
- `owners` — массив длиной `w*h`, значение `0` означает «ничья клетка», иначе `idx` владельца.
- `players[].trail` может отсутствовать/быть `null`, если след пустой.
- Клиент рисует территорию по `owners`, игроков по `players`, и таблицу лидеров по `leaderboard`.

---

## 8. Профиль и достижения

### 8.1 profile_get (клиент → сервер)

```json
{"type":"profile_get"}
```

### 8.2 profile (сервер → клиент)

```json
{
  "type":"profile",
  "username":"jez",
  "stats":{
    "totalKills":10,
    "totalArea":5000,
    "bestScore":200,
    "bestKillsInGame":7,
    "bestKillStreak":4
  },
  "achievements":["FIRST_BLOOD","AREA_1000"]
}
```

---

## 9. Ping (опционально)

### ping (клиент → сервер)

```json
{"type":"ping","t":1730000000000}
```

Сервер может отвечать тем же сообщением или игнорировать (зависит от реализации).

---

## 10. Ошибки

### error (сервер → клиент)

```json
{"type":"error","reason":"room_full"}
```

Рекомендуемые `reason` (не исчерпывающий список):
- `invalid_credentials`
- `already_authenticated`
- `room_full`
- `chat_rate_limit`
- `chat_too_long`
- `unknown_message`
- `not_authenticated`

---

## 11. Сценарии (пример)

1) Клиент подключается по TCP.  
2) Отправляет `login`/`register`.  
3) Получает `auth_ok` и автоматически попадает в комнату.  
4) Получает поток `state`, отправляет `input`, пользуется чатом.  
5) По кнопке `spectate` отправляет `join_room` с `spectator:true` — игрок становится невидимым на поле, но сохраняет чат.  
6) По кнопке `play` отправляет `join_room` с `spectator:false` — если есть места, создаётся сущность игрока.
